Index: app/src/main/res/layout/fragment_entrant_settings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><ScrollView\r\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\"\r\n    android:layout_width=\"match_parent\"\r\n    android:layout_height=\"match_parent\"\r\n    android:background=\"#0B0B18\"\r\n    tools:context=\".entrant.EntrantSettingsFragment\">\r\n\r\n    <LinearLayout\r\n        android:layout_width=\"match_parent\"\r\n        android:layout_height=\"wrap_content\"\r\n        android:orientation=\"vertical\">\r\n\r\n        <!-- HEADER BAR -->\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"56dp\"\r\n            android:orientation=\"horizontal\"\r\n            android:gravity=\"center_vertical\"\r\n            android:background=\"@android:color/white\"\r\n            android:paddingHorizontal=\"12dp\">\r\n\r\n            <ImageButton\r\n                android:id=\"@+id/button_back\"\r\n                android:layout_width=\"28dp\"\r\n                android:layout_height=\"28dp\"\r\n                android:background=\"@android:color/transparent\"\r\n                android:src=\"@drawable/ic_arrow_back\"\r\n                android:contentDescription=\"Back\"\r\n                app:tint=\"#000000\" />\r\n\r\n            <ImageView\r\n                android:id=\"@+id/image_logo\"\r\n                android:layout_width=\"28dp\"\r\n                android:layout_height=\"28dp\"\r\n                android:src=\"@drawable/wingman_logo\"\r\n                android:contentDescription=\"Logo\"\r\n                android:layout_marginStart=\"8dp\" />\r\n\r\n            <TextView\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:text=\"Settings\"\r\n                android:textColor=\"#000000\"\r\n                android:textStyle=\"bold\"\r\n                android:textSize=\"18sp\"\r\n                android:layout_marginStart=\"8dp\" />\r\n        </LinearLayout>\r\n\r\n        <!-- USER NAME -->\r\n        <TextView\r\n            android:id=\"@+id/text_user_name\"\r\n            android:layout_width=\"wrap_content\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_marginTop=\"24dp\"\r\n            android:text=\"Jane Doe\"\r\n            android:textSize=\"18sp\"\r\n            android:textStyle=\"bold\"\r\n            android:textColor=\"#FFFFFF\" />\r\n\r\n        <!-- SECTION: ACCOUNT SETTINGS -->\r\n        <TextView\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_marginTop=\"24dp\"\r\n            android:text=\"Account Settings\"\r\n            android:textColor=\"#B0B0B0\"\r\n            android:textSize=\"14sp\" />\r\n\r\n        <!-- Edit Profile Row -->\r\n        <LinearLayout\r\n            android:id=\"@+id/row_edit_profile\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"horizontal\"\r\n            android:gravity=\"center_vertical\"\r\n            android:paddingVertical=\"12dp\"\r\n            android:background=\"?android:attr/selectableItemBackground\">\r\n\r\n            <TextView\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"Edit profile\"\r\n                android:textColor=\"#FFFFFF\"\r\n                android:textSize=\"16sp\"/>\r\n\r\n            <ImageView\r\n                android:id=\"@+id/btn_edit_profile\"\r\n                android:layout_width=\"20dp\"\r\n                android:layout_height=\"20dp\"\r\n                android:src=\"@drawable/ic_chevron_right\"\r\n                app:tint=\"#FFFFFF\" />\r\n        </LinearLayout>\r\n\r\n        <!-- Notifications -->\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"horizontal\"\r\n            android:gravity=\"center_vertical\"\r\n            android:paddingVertical=\"8dp\">\r\n\r\n            <TextView\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"Notifications from admins\"\r\n                android:textColor=\"#FFFFFF\"\r\n                android:textSize=\"16sp\"/>\r\n\r\n            <Switch\r\n                android:id=\"@+id/switch_admin_notifications\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"/>\r\n        </LinearLayout>\r\n\r\n        <LinearLayout\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"horizontal\"\r\n            android:gravity=\"center_vertical\"\r\n            android:paddingVertical=\"8dp\">\r\n\r\n            <TextView\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"Notifications from organizers\"\r\n                android:textColor=\"#FFFFFF\"\r\n                android:textSize=\"16sp\"/>\r\n\r\n            <Switch\r\n                android:id=\"@+id/switch_organizer_notifications\"\r\n                android:layout_width=\"wrap_content\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:checked=\"true\"/>\r\n        </LinearLayout>\r\n\r\n        <!-- SECTION: MORE -->\r\n        <TextView\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:layout_marginTop=\"24dp\"\r\n            android:text=\"More\"\r\n            android:textColor=\"#B0B0B0\"\r\n            android:textSize=\"14sp\" />\r\n\r\n        <!-- About Us Row -->\r\n        <LinearLayout\r\n            android:id=\"@+id/row_about_us\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"wrap_content\"\r\n            android:orientation=\"horizontal\"\r\n            android:gravity=\"center_vertical\"\r\n            android:paddingVertical=\"12dp\"\r\n            android:background=\"?android:attr/selectableItemBackground\">\r\n\r\n            <TextView\r\n                android:layout_width=\"0dp\"\r\n                android:layout_height=\"wrap_content\"\r\n                android:layout_weight=\"1\"\r\n                android:text=\"About us\"\r\n                android:textColor=\"#FFFFFF\"\r\n                android:textSize=\"16sp\"/>\r\n\r\n            <ImageView\r\n                android:id=\"@+id/btn_about_us\"\r\n                android:layout_width=\"20dp\"\r\n                android:layout_height=\"20dp\"\r\n                android:src=\"@drawable/ic_chevron_right\"\r\n                app:tint=\"#FFFFFF\" />\r\n        </LinearLayout>\r\n\r\n        <!-- Logout & Delete Buttons -->\r\n        <Button\r\n            android:id=\"@+id/button_logout\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"48dp\"\r\n            android:layout_marginTop=\"24dp\"\r\n            android:text=\"Log Out\"\r\n            android:textSize=\"16sp\"\r\n            android:textColor=\"@android:color/white\"\r\n            android:background=\"@drawable/red_button_bg\"\r\n            android:backgroundTint=\"@null\"/>\r\n\r\n        <Button\r\n            android:id=\"@+id/button_delete_account\"\r\n            android:layout_width=\"match_parent\"\r\n            android:layout_height=\"48dp\"\r\n            android:layout_marginTop=\"12dp\"\r\n            android:text=\"Delete Account\"\r\n            android:textSize=\"16sp\"\r\n            android:textColor=\"@android:color/white\"\r\n            android:background=\"@drawable/red_button_bg\"\r\n            android:backgroundTint=\"@null\"/>\r\n\r\n    </LinearLayout>\r\n</ScrollView>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/layout/fragment_entrant_settings.xml b/app/src/main/res/layout/fragment_entrant_settings.xml
--- a/app/src/main/res/layout/fragment_entrant_settings.xml	(revision f3c1459e7397b2bf29ce485b8e14c636486208fd)
+++ b/app/src/main/res/layout/fragment_entrant_settings.xml	(date 1764038998181)
@@ -174,27 +174,28 @@
         </LinearLayout>
 
         <!-- Logout & Delete Buttons -->
+
         <Button
             android:id="@+id/button_logout"
             android:layout_width="match_parent"
             android:layout_height="48dp"
             android:layout_marginTop="24dp"
+            android:background="@drawable/red_button_bg"
+            android:backgroundTint="@null"
             android:text="Log Out"
-            android:textSize="16sp"
             android:textColor="@android:color/white"
-            android:background="@drawable/red_button_bg"
-            android:backgroundTint="@null"/>
+            android:textSize="16sp" />
 
         <Button
             android:id="@+id/button_delete_account"
             android:layout_width="match_parent"
             android:layout_height="48dp"
             android:layout_marginTop="12dp"
+            android:background="@drawable/red_button_bg"
+            android:backgroundTint="@null"
             android:text="Delete Account"
-            android:textSize="16sp"
             android:textColor="@android:color/white"
-            android:background="@drawable/red_button_bg"
-            android:backgroundTint="@null"/>
+            android:textSize="16sp" />
 
     </LinearLayout>
 </ScrollView>
Index: app/src/main/res/values/themes.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources xmlns:tools=\"http://schemas.android.com/tools\">\r\n    <!-- Base application theme. -->\r\n    <style name=\"Base.Theme.MagpieWingman\" parent=\"Theme.Material3.DayNight.NoActionBar\">\r\n        <item name=\"colorPrimary\">#2E5BFF</item>\r\n        <item name=\"colorPrimaryVariant\">#2E5BFF</item>\r\n        <item name=\"colorSecondary\">#2E5BFF</item>\r\n    </style>\r\n\r\n    <style name=\"Theme.MagpieWingman\" parent=\"Base.Theme.MagpieWingman\" />\r\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/themes.xml b/app/src/main/res/values/themes.xml
--- a/app/src/main/res/values/themes.xml	(revision f3c1459e7397b2bf29ce485b8e14c636486208fd)
+++ b/app/src/main/res/values/themes.xml	(date 1764038450838)
@@ -4,6 +4,7 @@
         <item name="colorPrimary">#2E5BFF</item>
         <item name="colorPrimaryVariant">#2E5BFF</item>
         <item name="colorSecondary">#2E5BFF</item>
+        <item name="android:windowBackground">@color/splash_dark</item>
     </style>
 
     <style name="Theme.MagpieWingman" parent="Base.Theme.MagpieWingman" />
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\r\n    xmlns:tools=\"http://schemas.android.com/tools\">\r\n\r\n    <application\r\n        android:name=\".MyApp\"\r\n        android:allowBackup=\"true\"\r\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\r\n        android:fullBackupContent=\"@xml/backup_rules\"\r\n        android:icon=\"@mipmap/ic_launcher\"\r\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\r\n        android:label=\"@string/app_name\"\r\n        android:supportsRtl=\"true\"\r\n        android:theme=\"@style/Theme.MagpieWingman\">\r\n\r\n        <!--\r\n             TODO: Before you run your application, you need a Google Maps API key.\r\n\r\n             To get one, follow the directions here:\r\n\r\n                https://developers.google.com/maps/documentation/android-sdk/get-api-key\r\n\r\n             Once you have your API key (it starts with \"AIza\"), define a new property in your\r\n             project's local.properties file (e.g. MAPS_API_KEY=Aiza...), and replace the\r\n             \"YOUR_API_KEY\" string in this file with \"${MAPS_API_KEY}\".\r\n        -->\r\n        <meta-data\r\n            android:name=\"com.google.android.geo.API_KEY\"\r\n            android:value=\"YOUR_API_KEY\" />\r\n\r\n        <activity\r\n            android:name=\".MainActivity\"\r\n            android:exported=\"true\"\r\n            android:theme=\"@style/Theme.MagpieWingman.Splash\">\r\n\r\n            <intent-filter>\r\n                <action android:name=\"android.intent.action.MAIN\" />\r\n                <category android:name=\"android.intent.category.LAUNCHER\" />\r\n            </intent-filter>\r\n\r\n        </activity>\r\n    </application>\r\n\r\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
--- a/app/src/main/AndroidManifest.xml	(revision f3c1459e7397b2bf29ce485b8e14c636486208fd)
+++ b/app/src/main/AndroidManifest.xml	(date 1764038450846)
@@ -31,7 +31,7 @@
         <activity
             android:name=".MainActivity"
             android:exported="true"
-            android:theme="@style/Theme.MagpieWingman.Splash">
+            android:theme="@style/Theme.MagpieWingman">
 
             <intent-filter>
                 <action android:name="android.intent.action.MAIN" />
Index: app/src/main/java/com/example/magpie_wingman/data/DbManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.magpie_wingman.data;\r\n\r\nimport android.content.Context;\r\nimport android.provider.Settings;\r\n\r\nimport androidx.annotation.Nullable;\r\n\r\nimport com.example.magpie_wingman.data.model.User;\r\nimport com.example.magpie_wingman.data.model.UserProfile;\r\nimport com.example.magpie_wingman.data.model.UserRole;\r\nimport com.google.android.gms.tasks.Task;\r\nimport com.google.android.gms.tasks.TaskCompletionSource;\r\nimport com.google.android.gms.tasks.Tasks;\r\nimport com.google.firebase.firestore.DocumentReference;\r\nimport com.google.firebase.firestore.DocumentSnapshot;\r\nimport com.google.firebase.firestore.FirebaseFirestore;\r\nimport com.google.firebase.firestore.Query;\r\nimport com.google.firebase.firestore.QuerySnapshot;\r\nimport com.google.firebase.firestore.SetOptions;\r\nimport com.google.firebase.firestore.WriteBatch;\r\n\r\nimport java.security.SecureRandom;\r\nimport java.util.ArrayList;\r\nimport java.util.Collections;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Locale;\r\nimport java.util.Map;\r\nimport java.util.concurrent.Executors;\r\n\r\n\r\n/**\r\n * This utility class contains all of the \"Helper Methods\" that read from and write to the database\r\n * Helper method functionalities include:\r\n * -  Creating and deleting users/events\r\n * -  Moving users to waitlist -> registrable -> registered subcollections in an event's doc\r\n * -  Removing users from the above subcollections\r\n * -  Changing user's organizer perms\r\n * -  Getters and setters for user/events' info\r\n */\r\npublic class DbManager {\r\n\r\n    private static DbManager instance;\r\n\r\n    private final FirebaseFirestore db;\r\n    private final Context appContext;\r\n    private final SecureRandom random = new SecureRandom();\r\n\r\n    private DbManager(Context context) {\r\n        this.appContext = context.getApplicationContext();\r\n        this.db = FirebaseFirestore.getInstance();\r\n    }\r\n\r\n    public static synchronized void init(Context context) {\r\n        if (instance == null) {\r\n            instance = new DbManager(context);\r\n        }\r\n    }\r\n\r\n    public static synchronized DbManager getInstance() {\r\n        if (instance == null) {\r\n            throw new IllegalStateException(\"DbManager not initialized. Call DbManager.init(context) first.\");\r\n        }\r\n        return instance;\r\n    }\r\n\r\n    public FirebaseFirestore getDb() {\r\n        return db;\r\n    }\r\n\r\n    /**\r\n     * Generates a unique internal ID for user documents by using the first name and a randomized 4 digit integer\r\n     * @param name - the inputted name for the user.\r\n     * @return userID the document ID for the user's firebase document\r\n     */\r\n    public String generateUserId(String name) {\r\n        String cleanName = name.trim().replaceAll(\"\\\\s+\", \"\").toLowerCase(Locale.ROOT);\r\n\r\n        while (true) {\r\n            int suffix = 1000 + random.nextInt(9000);\r\n            String userId = cleanName + \"#\" + suffix;\r\n\r\n            try {\r\n                DocumentSnapshot doc = Tasks.await(\r\n                        db.collection(\"users\").document(userId).get()\r\n                );\r\n\r\n                if (!doc.exists()) {\r\n                    return userId;\r\n                }\r\n\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n                return userId;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a new user document.\r\n     * The userId will be generated using generateUserID and will also act as the document ID\r\n     */\r\n    public Task<Void> createUser(String name, String email, String phone, String password) {\r\n        String userId = generateUserId(name);\r\n\r\n        Map<String, Object> user = new HashMap<>();\r\n        user.put(\"userId\", userId);\r\n        user.put(\"name\", name);\r\n        user.put(\"email\", email);\r\n        user.put(\"phone\", phone);\r\n        user.put(\"password\",password);\r\n        user.put(\"isOrganizer\", true);\r\n        user.put(\"deviceId\", Settings.Secure.getString(\r\n                appContext.getContentResolver(),\r\n                Settings.Secure.ANDROID_ID\r\n        ));\r\n\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .set(user, SetOptions.merge());\r\n\r\n    }\r\n\r\n    /**\r\n     * Creates a new event document in Firestore.\r\n     * The event ID is generated from the first word in the event name + random 4-digit number.\r\n     *\r\n     * @param eventName        the name of the event\r\n     * @param description      the event description\r\n     * @param organizerId      the userId of the organizer (to store reference)\r\n     * @param regStart         registration start date (String or Timestamp)\r\n     * @param regEnd           registration end date (String or Timestamp)\r\n     */\r\n    public Task<Void> createEvent(String eventName,\r\n                                  String description,\r\n                                  String organizerId,\r\n                                  Object regStart,\r\n                                  Object regEnd) {\r\n\r\n        String eventId;\r\n        DocumentSnapshot doc;\r\n\r\n        while (true) {\r\n            String firstWord = eventName.trim().split(\"\\\\s+\")[0].toLowerCase(Locale.ROOT);\r\n            int suffix = 1000 + random.nextInt(9000);\r\n            eventId = firstWord + \"#\" + suffix;\r\n\r\n            try {\r\n                doc = Tasks.await(db.collection(\"events\").document(eventId).get());\r\n                if (!doc.exists()) break; // no collision, proceed\r\n            } catch (Exception e) {\r\n                e.printStackTrace(); //if there's a collision it will show in the stack trace and retry a new number\r\n                continue;\r\n            }\r\n        }\r\n\r\n        Map<String, Object> event = new HashMap<>();\r\n        event.put(\"eventId\", eventId);\r\n        event.put(\"eventName\", eventName);\r\n        event.put(\"description\", description);\r\n        event.put(\"organizerId\", organizerId);\r\n        event.put(\"registrationStart\", regStart);\r\n        event.put(\"registrationEnd\", regEnd);\r\n\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .set(event, SetOptions.merge());\r\n    }\r\n    public Task<Void> deleteEntrant(String userId) {\r\n        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();\r\n\r\n        Executors.newSingleThreadExecutor().execute(() -> {\r\n            try {\r\n                // Get all events\r\n                QuerySnapshot eventsSnap = Tasks.await(db.collection(\"events\").get());\r\n\r\n                // Single batch (no chunking)\r\n                WriteBatch batch = db.batch();\r\n\r\n                for (DocumentSnapshot ev : eventsSnap.getDocuments()) {\r\n                    com.google.firebase.firestore.DocumentReference evRef = ev.getReference();\r\n\r\n                    // waitlist\r\n                    QuerySnapshot wl = Tasks.await(\r\n                            evRef.collection(\"waitlist\").whereEqualTo(\"userId\", userId).get()\r\n                    );\r\n                    for (DocumentSnapshot d : wl.getDocuments()) {\r\n                        batch.delete(d.getReference());\r\n                    }\r\n\r\n                    // registrable\r\n                    QuerySnapshot rg = Tasks.await(\r\n                            evRef.collection(\"registrable\").whereEqualTo(\"userId\", userId).get()\r\n                    );\r\n                    for (DocumentSnapshot d : rg.getDocuments()) {\r\n                        batch.delete(d.getReference());\r\n                    }\r\n\r\n                    // registered\r\n                    QuerySnapshot rd = Tasks.await(\r\n                            evRef.collection(\"registered\").whereEqualTo(\"userId\", userId).get()\r\n                    );\r\n                    for (DocumentSnapshot d : rd.getDocuments()) {\r\n                        batch.delete(d.getReference());\r\n                    }\r\n                }\r\n\r\n                // Finally delete the user doc\r\n                batch.delete(db.collection(\"users\").document(userId));\r\n\r\n                // Commit once\r\n                Tasks.await(batch.commit());\r\n                tcs.setResult(null);\r\n            } catch (Exception e) {\r\n                tcs.setException(e);\r\n            }\r\n        });\r\n\r\n        return tcs.getTask();\r\n    }\r\n\r\n    public Task<Void> deleteOrganizer(String organizerId) {\r\n        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();\r\n\r\n        Executors.newSingleThreadExecutor().execute(() -> {\r\n            try {\r\n                QuerySnapshot organizerEvents = Tasks.await(\r\n                        db.collection(\"events\")\r\n                                .whereEqualTo(\"organizerId\", organizerId)\r\n                                .get()\r\n                );\r\n\r\n                List<Task<Void>> deletes = new ArrayList<>();\r\n                for (DocumentSnapshot d : organizerEvents.getDocuments()) {\r\n                    deletes.add(deleteEvent(d.getId()));\r\n                }\r\n\r\n                Tasks.await(Tasks.whenAll(deletes));\r\n                Tasks.await(deleteEntrant(organizerId));\r\n\r\n                tcs.setResult(null);\r\n            } catch (Exception e) {\r\n                tcs.setException(e);\r\n            }\r\n        });\r\n\r\n        return tcs.getTask();\r\n    }\r\n\r\n    public Task<Void> revokeOrganizerAndDeleteEvents(String organizerId) {\r\n        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();\r\n\r\n        Executors.newSingleThreadExecutor().execute(() -> {\r\n            try {\r\n                // 1) Revoke organizer role\r\n                Tasks.await(changeOrgPerms(organizerId, false));\r\n\r\n                // 2) Find all events they own (your schema uses \"organizerId\")\r\n                QuerySnapshot organizerEvents = Tasks.await(\r\n                        db.collection(\"events\")\r\n                                .whereEqualTo(\"organizerId\", organizerId)\r\n                                .get()\r\n                );\r\n\r\n                // 3) Delete each event (deep) using your existing helper\r\n                List<Task<Void>> deletes = new ArrayList<>();\r\n                for (DocumentSnapshot d : organizerEvents.getDocuments()) {\r\n                    deletes.add(deleteEvent(d.getId()));\r\n                }\r\n                Tasks.await(Tasks.whenAll(deletes));\r\n\r\n                tcs.setResult(null);\r\n            } catch (Exception e) {\r\n                tcs.setException(e);\r\n            }\r\n        });\r\n\r\n        return tcs.getTask();\r\n    }\r\n\r\n    public Task<List<UserProfile>> fetchProfiles(@Nullable UserRole roleFilter) {\r\n        TaskCompletionSource<List<UserProfile>> tcs = new TaskCompletionSource<>();\r\n\r\n        Executors.newSingleThreadExecutor().execute(() -> {\r\n            try {\r\n                Query q = db.collection(\"users\");\r\n                if (roleFilter == UserRole.ORGANIZER) {\r\n                    q = q.whereEqualTo(\"isOrganizer\", true);\r\n                } else if (roleFilter == UserRole.ENTRANT) {\r\n                    q = q.whereEqualTo(\"isOrganizer\", false);\r\n                }\r\n\r\n                QuerySnapshot snap = Tasks.await(q.get());\r\n\r\n                List<UserProfile> out = new ArrayList<>();\r\n                for (DocumentSnapshot d : snap.getDocuments()) {\r\n                    String userId = d.getId();\r\n                    String name = d.getString(\"name\");\r\n                    String image = d.getString(\"profileImageUrl\");\r\n                    Boolean isOrg = d.getBoolean(\"isOrganizer\");\r\n\r\n                    UserRole role = (isOrg != null && isOrg)\r\n                            ? UserRole.ORGANIZER\r\n                            : UserRole.ENTRANT;\r\n\r\n                    if (roleFilter == null || role == roleFilter) {out.add(new UserProfile(userId,\r\n                            name, role));\r\n                    }\r\n                }\r\n\r\n                tcs.setResult(out);\r\n            } catch (Exception e) {\r\n                tcs.setException(e);\r\n            }\r\n        });\r\n        return tcs.getTask();\r\n    }\r\n    /**\r\n     * Deletes a user profile based on their role.\r\n     *\r\n     * @param userId the Firestore document id of the user\r\n     * @param role   the user's current role\r\n     * @return a Task that completes when all writes are finished or fails with the underlying exception\r\n     */\r\n    public Task<Void> deleteProfile(String userId, com.example.magpie_wingman.data.model.UserRole role) {\r\n        if (role == com.example.magpie_wingman.data.model.UserRole.ORGANIZER) {\r\n            return deleteOrganizer(userId);\r\n        }\r\n        return deleteEntrant(userId);\r\n    }\r\n\r\n    /**\r\n     * Helper function that checks if user is in a waitlist\r\n     * @param eventId eventId of the event waitlist to check\r\n     * @param userId userId of the user to check\r\n     * @return\r\n     */\r\n    public Task<Boolean> isUserInWaitlist(String eventId, String userId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"waitlist\")\r\n                .document(userId)\r\n                .get()\r\n                .continueWith(task ->\r\n                        task.isSuccessful() && task.getResult() != null && task.getResult().exists());\r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * Deletes an event document and its subcollections\r\n     * (\"waitlist\", \"registrable\", \"registered\") from Firestore.\r\n     *\r\n     * @param eventId The ID of the event to delete.\r\n     * @return A Task that completes when the delete finishes. Result is {@code null} if success.)\r\n     */\r\n    public Task<Void> deleteEvent(String eventId) {\r\n        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>(); //I create a custom task for methods that require multiple firestore tasks.\r\n\r\n        Executors.newSingleThreadExecutor().execute(() -> { //since we await here we want to create a background thread to avoid freezing UI\r\n            try {\r\n                // reference to the event doc to delete\r\n                DocumentReference eventRef = db.collection(\"events\").document(eventId);\r\n\r\n                // get subcollections' docs\r\n                QuerySnapshot waitlistSnap = Tasks.await( //we await to make sure we have all of the references to the subcollection before deleting everything\r\n                        eventRef.collection(\"waitlist\").get()\r\n                );\r\n                QuerySnapshot registrableSnap = Tasks.await(\r\n                        eventRef.collection(\"registrable\").get()\r\n                );\r\n                QuerySnapshot registeredSnap = Tasks.await(\r\n                        eventRef.collection(\"registered\").get()\r\n                );\r\n\r\n                WriteBatch batch = db.batch();\r\n\r\n                // delete all user docs\r\n                for (DocumentSnapshot doc : waitlistSnap.getDocuments()) {\r\n                    batch.delete(doc.getReference());\r\n                }\r\n\r\n                for (DocumentSnapshot doc : registrableSnap.getDocuments()) {\r\n                    batch.delete(doc.getReference());\r\n                }\r\n\r\n                for (DocumentSnapshot doc : registeredSnap.getDocuments()) {\r\n                    batch.delete(doc.getReference());\r\n                }\r\n\r\n                // now we can delete the actual event doc\r\n                batch.delete(eventRef);\r\n\r\n                // commit and wait until it's done\r\n                Tasks.await(batch.commit());\r\n\r\n                //if success set result to null (success)\r\n                tcs.setResult(null);\r\n            } catch (Exception e) {\r\n                tcs.setException(e); //exception handling\r\n            }\r\n        });\r\n\r\n        return tcs.getTask();\r\n    }\r\n\r\n    /**\r\n     * Adds a userID document to the event document's waitlist subcollection (creates one if it doesn't exist yet)\r\n     * @param eventId - ID of event doc in question\r\n     * @param userId - ID of the user\r\n     * @return\r\n     */\r\n    public Task<Void> addUserToWaitlist(String eventId, String userId) {\r\n        Map<String, Object> data = new HashMap<>();\r\n        data.put(\"userId\", userId);\r\n        data.put(\"addedAt\", System.currentTimeMillis());  // simple timestamp\r\n\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"waitlist\")\r\n                .document(userId)\r\n                .set(data, SetOptions.merge());\r\n    }\r\n\r\n    /**\r\n     * Randomly selects count users from an event's waitlist and moves them\r\n     * to the \"registrable\" subcollection in Firestore.\r\n     *\r\n     * @param eventId The ID of the event to update.\r\n     * @param count   The number of users to switch from waitlist to registrable.\r\n     * @return A google.android.gms.tasks.Task that completes when all Firestore\r\n     *         reads and writes are finished (result is null on success).\r\n     */\r\n    public Task<Void> addUsersToRegistrable(String eventId, int count) {\r\n        //create an empty task for this as its more complex. Will tell callers if and when it succeeds.\r\n        TaskCompletionSource<Void> tcs = new TaskCompletionSource<>();\r\n\r\n        // create a background thread so this doesn't freeze the UI (has an await).\r\n        // Actual method operation code is wrapped in this\r\n        Executors.newSingleThreadExecutor().execute(() -> {\r\n            try {\r\n                //query the waitlist subcollection\r\n                QuerySnapshot waitlistSnap = Tasks.await(\r\n                        db.collection(\"events\")\r\n                                .document(eventId)\r\n                                .collection(\"waitlist\")\r\n                                .get()\r\n                );\r\n\r\n                List<DocumentSnapshot> waitlistDocs = waitlistSnap.getDocuments(); //list of waitlist user documents\r\n\r\n                if (waitlistDocs.isEmpty() || count <= 0) {\r\n                    tcs.setResult(null);\r\n                    return;\r\n                }\r\n\r\n                // randomize order of the waitlist users\r\n                Collections.shuffle(waitlistDocs, random);\r\n\r\n                // select first x users\r\n                int actualCount = Math.min(count, waitlistDocs.size());\r\n\r\n                //Use batch to reduce number of read/writes\r\n                WriteBatch batch = db.batch();\r\n\r\n                for (int i = 0; i < actualCount; i++) {\r\n                    DocumentSnapshot userDoc = waitlistDocs.get(i);\r\n                    String userId = userDoc.getId();\r\n\r\n                    DocumentReference waitlistRef = db.collection(\"events\")\r\n                            .document(eventId)\r\n                            .collection(\"waitlist\")\r\n                            .document(userId);\r\n\r\n                    DocumentReference registrableRef = db.collection(\"events\")\r\n                            .document(eventId)\r\n                            .collection(\"registrable\")\r\n                            .document(userId);\r\n\r\n                    Map<String, Object> regData = new HashMap<>();\r\n                    regData.put(\"userId\", userId);\r\n                    regData.put(\"invitedAt\", System.currentTimeMillis());\r\n\r\n                    batch.set(registrableRef, regData, SetOptions.merge());\r\n                    batch.delete(waitlistRef);\r\n                }\r\n\r\n                // commit the changes in a batch. We await before returning the task\r\n                Tasks.await(batch.commit());\r\n\r\n                // If no exceptions, set the task result to success (null)\r\n                tcs.setResult(null);\r\n\r\n                // If not, set the result to the exception.\r\n            } catch (Exception e) {\r\n                tcs.setException(e);\r\n            }\r\n        });\r\n        //return the task result to the caller\r\n        return tcs.getTask();\r\n    }\r\n    public Task<Void> addUserToRegistered(String eventId, String userId) {\r\n\r\n        com.google.firebase.firestore.WriteBatch batch = db.batch();\r\n\r\n        // source doc (registrable)\r\n        com.google.firebase.firestore.DocumentReference registrableRef =\r\n                db.collection(\"events\")\r\n                        .document(eventId)\r\n                        .collection(\"registrable\")\r\n                        .document(userId);\r\n\r\n        // target doc (registered)\r\n        com.google.firebase.firestore.DocumentReference registeredRef =\r\n                db.collection(\"events\")\r\n                        .document(eventId)\r\n                        .collection(\"registered\")\r\n                        .document(userId);\r\n\r\n        // copy minimal data\r\n        Map<String, Object> data = new HashMap<>();\r\n        data.put(\"userId\", userId);\r\n        data.put(\"movedAt\", System.currentTimeMillis());\r\n\r\n        // write to registered\r\n        batch.set(registeredRef, data, SetOptions.merge());\r\n        // delete from registrable\r\n        batch.delete(registrableRef);\r\n\r\n        return batch.commit();\r\n    }\r\n\r\n    /**\r\n     * Removes the given user from the waitlist of the given event.\r\n     *\r\n     * @param eventId The event to update.\r\n     * @param userId  The user to remove.\r\n     * @return A Task that completes when the delete finishes.\r\n     */\r\n    public Task<Void> cancelWaitlist(String eventId, String userId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"waitlist\")\r\n                .document(userId)\r\n                .delete();\r\n    }\r\n\r\n    /**\r\n     * Removes the given user from the registrable of the given event.\r\n     *\r\n     * @param eventId The event to update.\r\n     * @param userId  The user to remove.\r\n     * @return A Task that completes when the delete finishes.\r\n     */\r\n    public Task<Void> cancelRegistrable(String eventId, String userId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"registrable\")\r\n                .document(userId)\r\n                .delete();\r\n    }\r\n\r\n    /**\r\n     * Removes the given user from the registered subcollection of the given event.\r\n     *\r\n     * @param eventId The event to update.\r\n     * @param userId  The user to remove.\r\n     * @return A Task that completes when the delete finishes.\r\n     */\r\n    public Task<Void> cancelRegistered(String eventId, String userId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"registered\")\r\n                .document(userId)\r\n                .delete();\r\n    }\r\n    /**\r\n     * Updates the user's display name.\r\n     *\r\n     * @param userId  ID of the user document to update.\r\n     * @param newName New name to set.\r\n     * @return Task that completes when the update finishes.\r\n     */\r\n    public Task<Void> updateName(String userId, String newName) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"name\", newName);\r\n    }\r\n\r\n    /**\r\n     * Updates the user's email address.\r\n     *\r\n     * @param userId   ID of the user document to update.\r\n     * @param newEmail New email to set.\r\n     * @return Task that completes when the update finishes.\r\n     */\r\n    public Task<Void> updateEmail(String userId, String newEmail) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"email\", newEmail);\r\n    }\r\n\r\n    /**\r\n     * Updates the user's phone number.\r\n     *\r\n     * @param userId     ID of the user document to update.\r\n     * @param newPhone   New phone number to set.\r\n     * @return Task that completes when the update finishes.\r\n     */\r\n    public Task<Void> updatePhoneNumber(String userId, String newPhone) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"phone\", newPhone);\r\n    }\r\n\r\n    /**\r\n     * Changes a user's organizer permissions.\r\n     *\r\n     * @param userId      The ID of the user to update.\r\n     * @param isOrganizer True to grant organizer permissions; false to revoke them.\r\n     * @return A Task that completes when the update finishes.\r\n     */\r\n    public Task<Void> changeOrgPerms(String userId, boolean isOrganizer) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"isOrganizer\", isOrganizer);\r\n    }\r\n\r\n    /**\r\n     * Gets the user's name from Firestore.\r\n     *\r\n     * @param userId ID of the user document.\r\n     * @return Task resolving to the user's name.\r\n     */\r\n    public Task<String> getUserName(String userId) {\r\n        return db.collection(\"users\").document(userId)\r\n                .get()\r\n                .continueWith(task -> task.getResult().getString(\"name\"));\r\n    }\r\n\r\n    /**\r\n     * Gets the user's email from Firestore.\r\n     *\r\n     * @param userId ID of the user document.\r\n     * @return Task resolving to the user's email.\r\n     */\r\n    public Task<String> getUserEmail(String userId) {\r\n        return db.collection(\"users\").document(userId)\r\n                .get()\r\n                .continueWith(task -> task.getResult().getString(\"email\"));\r\n    }\r\n\r\n    /**\r\n     * Gets whether the user is an organizer.\r\n     *\r\n     * @param userId ID of the user document.\r\n     * @return Task resolving to true if organizer, false otherwise.\r\n     */\r\n    public Task<Boolean> getIsOrganizer(String userId) {\r\n        return db.collection(\"users\").document(userId)\r\n                .get()\r\n                .continueWith(task -> task.getResult().getBoolean(\"isOrganizer\"));\r\n    }\r\n\r\n    /**\r\n     * Gets the user's phone number.\r\n     *\r\n     * @param userId ID of the user document.\r\n     * @return Task resolving to the user's phone number.\r\n     */\r\n    public Task<String> getUserPhone(String userId) {\r\n        return db.collection(\"users\").document(userId)\r\n                .get()\r\n                .continueWith(task -> task.getResult().getString(\"phone\"));\r\n    }\r\n\r\n    /**\r\n     * Gets the device ID stored for the user.\r\n     *\r\n     * @param userId ID of the user document.\r\n     * @return Task resolving to the user's device ID.\r\n     */\r\n    public Task<String> getUserDeviceId(String userId) {\r\n        return db.collection(\"users\").document(userId)\r\n                .get()\r\n                .continueWith(task -> task.getResult().getString(\"deviceId\"));\r\n    }\r\n    /**\r\n     * Gets the organizer ID associated with a given event.\r\n     *\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to the organizer's user ID as a String,\r\n     *         or null if the event does not exist or the field is missing.\r\n     */\r\n    public Task<String> getEventOrganizer(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return null;\r\n                    }\r\n                    return task.getResult().getString(\"organizerId\");\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Gets the description of a given event.\r\n     *\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to the event's description as a String,\r\n     *         or null if the event does not exist or the field is missing.\r\n     */\r\n    public Task<String> getEventDescription(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return null;\r\n                    }\r\n                    return task.getResult().getString(\"description\");\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Retrieves the registration period start value for a given event.\r\n     *\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to the registration start Object,\r\n     *         or null if the event does not exist or the field is missing.\r\n     */\r\n    public Task<Object> getEventRegistrationStart(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return null;\r\n                    }\r\n                    // you saved regStart as Object, so return as-is\r\n                    return task.getResult().get(\"registrationStart\");\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Retrieves the registration period end value for a given event.\r\n\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to the registration end Object,\r\n     *         or null if the event does not exist or the field is missing.\r\n     */\r\n    public Task<Object> getEventRegistrationEnd(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return null;\r\n                    }\r\n                    return task.getResult().get(\"registrationEnd\");\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Retrieves all user IDs currently on the waitlist for a given event.\r\n     *\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to a List of user IDs (Strings)\r\n     *         representing users in the \"waitlist\" subcollection.\r\n     *         Returns an empty list if the event or subcollection is missing.\r\n     */\r\n    public Task<List<String>> getEventWaitlist(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"waitlist\")\r\n                .get()\r\n                .continueWith(task -> {\r\n                    List<String> users = new ArrayList<>();\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return users;\r\n                    }\r\n                    for (DocumentSnapshot doc : task.getResult().getDocuments()) {\r\n                        users.add(doc.getId());\r\n                    }\r\n                    return users;\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Retrieves all user IDs currently marked as registrable for a given event.\r\n     *\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to a List of user IDs (Strings)\r\n     *         representing users in the \"registrable\" subcollection.\r\n     *         Returns an empty list if the event or subcollection is missing.\r\n     */\r\n    public Task<List<String>> getEventRegistrable(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"registrable\")\r\n                .get()\r\n                .continueWith(task -> {\r\n                    List<String> users = new ArrayList<>();\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return users;\r\n                    }\r\n                    for (DocumentSnapshot doc : task.getResult().getDocuments()) {\r\n                        users.add(doc.getId());\r\n                    }\r\n                    return users;\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Retrieves all user IDs currently registered for a given event.\r\n     *\r\n     * @param eventId The unique identifier of the event.\r\n     * @return A Task that resolves to a List of user IDs (Strings)\r\n     *         representing users in the \"registered\" subcollection.\r\n     *         Returns an empty list if the event or subcollection is missing.\r\n     */\r\n    public Task<List<String>> getEventRegistered(String eventId) {\r\n        return db.collection(\"events\")\r\n                .document(eventId)\r\n                .collection(\"registered\")\r\n                .get()\r\n                .continueWith(task -> {\r\n                    List<String> users = new ArrayList<>();\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        return users;\r\n                    }\r\n                    for (DocumentSnapshot doc : task.getResult().getDocuments()) {\r\n                        users.add(doc.getId());\r\n                    }\r\n                    return users;\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Updates the user's password.\r\n     *\r\n     * @param userId     ID of the user document to update.\r\n     * @param newPassword   New password.\r\n     * @return Task that completes when the update finishes.\r\n     */\r\n    public Task <Void> updatePassword(String userId, String newPassword) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"password\", newPassword);\r\n    }\r\n\r\n    /**\r\n     * Adds/Updates user's date of birth.\r\n     *\r\n     * @param userId     ID of the user document to update.\r\n     * @param newDOB   New phone number to set.\r\n     * @return Task that completes when the update finishes.\r\n     */\r\n\r\n    public Task<Void> updateDOB(String userId, Date newDOB) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"dateOfBirth\", newDOB);\r\n    }\r\n\r\n    public Task<String> findUserByDeviceId(String deviceId) {\r\n        return db.collection(\"users\")\r\n                .whereEqualTo(\"deviceId\", deviceId)\r\n                .limit(1)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful() || task.getResult().isEmpty()) {\r\n                        return null; // No match found\r\n                    }\r\n                    return task.getResult().getDocuments().get(0).getId(); // Return userId\r\n                });\r\n    }\r\n\r\n    /**\r\n     * Logs in a user by email + password.\r\n     *\r\n     * Firestore schema assumptions:\r\n     *  - Collection: \"users\"\r\n     *  - Fields: \"email\" (String), \"password\" (String), plus whatever else your User model has.\r\n     *\r\n     * @param email    User's email address.\r\n     * @param password User's password (plain-text for this assignment).\r\n     * @return Task resolving to the matching User on success, or failing with an Exception on error.\r\n     */\r\n    public Task<User> loginWithEmailAndPassword(String email, String password) {\r\n        return db.collection(\"users\")\r\n                .whereEqualTo(\"email\", email)\r\n                .limit(1)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful()) {\r\n                        throw task.getException() != null\r\n                                ? task.getException()\r\n                                : new Exception(\"Login query failed\");\r\n                    }\r\n\r\n                    QuerySnapshot snap = task.getResult();\r\n                    if (snap == null || snap.isEmpty()) {\r\n                        throw new Exception(\"Invalid email or password\");\r\n                    }\r\n\r\n                    DocumentSnapshot doc = snap.getDocuments().get(0);\r\n\r\n                    // Check password directly from the document\r\n                    String storedPassword = doc.getString(\"password\");\r\n                    if (storedPassword == null || !storedPassword.equals(password)) {\r\n                        throw new Exception(\"Invalid email or password\");\r\n                    }\r\n\r\n                    // Build a proper User with the correct, immutable userId\r\n                    return User.from(doc);\r\n                });\r\n    }\r\n\r\n    public com.google.android.gms.tasks.Task<Boolean> isEmailInUse(String email) {\r\n        return db.collection(\"users\")\r\n                .whereEqualTo(\"email\", email)\r\n                .limit(1)\r\n                .get()\r\n                .continueWith(task -> {\r\n                    if (!task.isSuccessful() || task.getResult() == null) {\r\n                        // Treat failure as \"not in use\" for now, but you can tighten this if you want\r\n                        return false;\r\n                    }\r\n                    return !task.getResult().isEmpty();\r\n                });\r\n    }\r\n\r\n    public com.google.android.gms.tasks.Task<Void> updateDOBByEmail(String email, java.util.Date newDOB) {\r\n        return db.collection(\"users\")\r\n                .whereEqualTo(\"email\", email)\r\n                .limit(1)\r\n                .get()\r\n                .continueWithTask(task -> {\r\n                    if (!task.isSuccessful() || task.getResult() == null || task.getResult().isEmpty()) {\r\n                        // No user found or error; you can also choose to throw here instead\r\n                        return com.google.android.gms.tasks.Tasks.forResult(null);\r\n                    }\r\n\r\n                    String userId = task.getResult().getDocuments().get(0).getId();\r\n                    return updateDOB(userId, newDOB);\r\n                });\r\n    }\r\n\r\n    public Task<Void> updateRememberMe(String userId, boolean rememberMe) {\r\n        return db.collection(\"users\")\r\n                .document(userId)\r\n                .update(\"rememberMe\", rememberMe);\r\n    }\r\n}\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/magpie_wingman/data/DbManager.java b/app/src/main/java/com/example/magpie_wingman/data/DbManager.java
--- a/app/src/main/java/com/example/magpie_wingman/data/DbManager.java	(revision f3c1459e7397b2bf29ce485b8e14c636486208fd)
+++ b/app/src/main/java/com/example/magpie_wingman/data/DbManager.java	(date 1764038587475)
@@ -869,16 +869,18 @@
     public Task<String> findUserByDeviceId(String deviceId) {
         return db.collection("users")
                 .whereEqualTo("deviceId", deviceId)
+                .whereEqualTo("rememberMe", true)   // only consider rememberme users
                 .limit(1)
                 .get()
                 .continueWith(task -> {
-                    if (!task.isSuccessful() || task.getResult().isEmpty()) {
-                        return null; // No match found
+                    if (!task.isSuccessful() || task.getResult() == null || task.getResult().isEmpty()) {
+                        return null; // No remembered user on this device
                     }
                     return task.getResult().getDocuments().get(0).getId(); // Return userId
                 });
     }
 
+
     /**
      * Logs in a user by email + password.
      *
